# Technologies Used in the Project

## Java with Spring Boot

Reason for Use: 
Java, with its extensive familiarity and expertise within the team, was chosen to meet time constraints and ensure efficient progress. Spring Boot, a framework built on top of Java, was utilized for its robust ecosystem and extensive libraries, which expedite development tasks, particularly in web application development.
Considered Alternatives: Python was considered due to its simplicity and suitability for AWS S3 interactions. However, the lack of team expertise and potential longer development time led to the decision not to use it, especially given time constraints.

## JUnit and Maven

Reason for Use: JUnit was employed to facilitate robust and automated unit testing, seamlessly integrating with Maven for streamlined project setup and dependency management. Both tools were chosen due to extensive familiarity and experience within the team.
Considered Alternatives: No alternatives were considered, as JUnit and Maven are widely adopted and well-suited for Java projects.

## Docker

Reason for Use: Docker was selected for its lightweight containerization, allowing for consistent deployment across environments with minimal setup.
Considered Alternatives: While other containerization solutions were considered, Docker's ease of use and popularity made it the preferred choice.

## Docker Swarm

Reason for Use: Docker Swarm was chosen for orchestration and management of containerized services, ensuring scalability and resilience while offering full control over deployment, scaling, and maintenance.
Considered Alternatives: Other orchestration tools such as Kubernetes were considered, but Docker Swarm's compatibility with Docker containers and finer-grained control made it the preferred choice.

## RabbitMQ

Reason for Use: RabbitMQ was selected as a reliable messaging system with support for various messaging patterns, seamless integration with Java, and ease of use.
Considered Alternatives: Apache Kafka was considered, but RabbitMQ's simplicity and seamless integration with Java favored its selection.

## H264 Codec

Reason for Use: The H264 codec was chosen for its longevity, widespread device compatibility, extensive support, and ease of use.
Considered Alternatives: Newer codecs like VP9 were considered, but their relative novelty and limited device support posed potential risks.

## HLS (HTTP Live Streaming)

Reason for Use: HLS was chosen for its simplicity in implementation and widespread native support across devices and platforms.
Considered Alternatives: DASH was considered, but HLS aligned closely with current priorities and offered ease of setup and compatibility.

## FFmpeg

Reason for Use: FFmpeg was selected for its comprehensive and robust multimedia processing tools, facilitating efficient video segmentation and transcoding. Its widespread acceptance ensured reliability and stability.
Considered Alternatives: Alternatives such as GStreamer, HandBrake, and Libav were considered, but FFmpeg's versatility, robustness, and widespread acceptance made it the preferred choice.

## MongoDB

Reason for Use: MongoDB was chosen for its simplicity and ease of management, aligning well with the project timeline. Its JSON-based data storage also aligned with the type of data being stored, and a pre-made Docker image was available for convenient deployment.
Considered Alternatives: Alternatives such as Apache Cassandra, Apache HBase, and Google Cloud Bigtable were considered, but their steeper learning curves and increased management complexity were deemed less suitable for the project's requirements.




